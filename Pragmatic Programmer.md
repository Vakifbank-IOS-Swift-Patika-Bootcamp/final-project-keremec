- [ ] Pragmatic Programmer

- [ ] Run through the conversation in your mind. What is the other person likely to say? Will they ask, “Have you tried this...” or “Didn’t you consider that?” How will you respond? Before you go and tell them the bad news, is there anything else you can try? Sometimes, you just know what they are going to say, so save them the trouble.
- [ ] When disorder increases in software, we call it “software rot.” Some folks might call it by the more optimistic term, “technical debt,” with the implied notion that they’ll pay it back someday. They probably won’t.
- [ ] Don’t leave “broken windows’’ (bad designs, wrong decisions, or poor code) unrepaired. Fix each one as soon as it is discovered. If there is insufficient time to fix it properly, then board it up. Perhaps you can comment out the offending code, or display a “Not Implemented” message, or substitute dummy data instead. Take some action to prevent further damage and to show that you’re on top of the situation.
- [ ] By the same token, if you find yourself on a project where the code is pristinely beautiful—cleanly written, well designed, and elegant—you will likely take extra special care not to mess it up, just like the firefighters. Even if there’s a fire raging (deadline, release date, trade show demo, etc.), you don’t want to be the first one to make a mess and inflict additional damage.
- [ ] Surprisingly, many users would rather use software with some rough edges today than wait a year for the shiny, bells-and- whistles version (and in fact what they will need a year from now may be completely different anyway). Many IT departments with tight budgets would agree. Great software today is often preferable to the fantasy of perfect software tomorrow. If you give your users something to play with early, their feedback will often lead you to a better eventual solution.
- [ ] Good Design Is Easier to Change Than Bad Design
- [ ] when some single facet of the code has to change, do you find yourself making that change in multiple places, and in multiple different formats? Do you have to change code and documentation, or a database schema and a structure that holds it, or...? If so, your code isn’t DRY.
- [ ] There is an easy test for orthogonal design. Once you have your components mapped out, ask yourself: If I dramatically change the requirements behind a particular function, how many modules are affected? In an orthogonal system, the answer should be “one.’’[16] Moving a button on a GUI panel should not require a change in the database schema. Adding context- sensitive help should not change the billing subsystem.
- [ ] Tracer development is consistent with the idea that a project is never finished: there will always be changes required and functions to add. It is an incremental approach.
- [ ] We tend to think of prototypes as code-based, but they don’t always have to be. Like the car makers, we can build prototypes out of different materials. Post-it notes are great for prototyping dynamic things such as workflow and application logic. A user interface can be prototyped as a drawing on a whiteboard, as a nonfunctional mock-up drawn with a paint program, or with an interface builder.
- [ ] But if you find yourself in an environment where you cannot give up the details, then you need to ask yourself if you are really building a prototype at all. Perhaps a tracer bullet style of development would be more appropriate in this case 
- [ ] One of the interesting things about estimating is that the units you use make a difference in the interpretation of the result. If you say that something will take about 130 working days, then people will be expecting it to come in pretty close. However, if you say “Oh, about six months,” then they know to look for it any time between five and seven months from now.
- [ ] You need to be able to manipulate text as effortlessly as possible, because text is the basic raw material of programming.
- [ ] First, look at yourself while you’re editing. Every time you find yourself doing something repetitive, get into the habit of thinking “there must be a better way.” Then find it.
- [ ] When you come across a surprise bug, beyond merely fixing it, you need to determine why this failure wasn’t caught earlier. Consider whether you need to amend the unit or other tests so that they would have caught it.
- [ ] One of the benefits of detecting problems as soon as you can is that you can crash earlier, and crashing is often the best thing you can do. The alternative may be to continue, writing corrupted data to some vital database or commanding the washing machine into its twentieth consecutive spin cycle.
- [ ] A supervisor is responsible for running code and knows what to do in case the code fails, which could include cleaning up after it, restarting it, and so on. What happens when the supervisor itself fails? Its own supervisor manages that event, leading to a design composed of supervisor trees. 
- [ ] the basic principle stays the same—when your code discovers that something that was supposed to be impossible just happened, your program is no longer viable. Anything it does from this point forward becomes suspect, so terminate it
- [ ] A dead program normally does a lot less damage than a crippled one.
- [ ] People often talk about something called the Law of Demeter, or LoD, in relation to coupling. The LoD is a set of guidelines[37] written in the late ’80s by Ian Holland. He created them to help developers on the Demeter Project keep their functions cleaner and decoupled.
- [ ] Try not to have more than one “.” when you access something. And access something also covers cases where you use intermediate variables
- [ ] There’s a big exception to the one-dot rule: the rule doesn’t apply if the things you’re chaining are really, really unlikely to change. In practice, anything in your application should be considered likely to change. Anything in a third-party library should be considered volatile, particularly if the maintainers of that library are known to change APIs between releases. Libraries that come with the language, however, are probably pretty stable, and so we’d be happy with code
- [ ] When you make code reusable, you give it clean interfaces, decoupling it from the rest of your code. This allows you to extract a method or module without dragging everything else along with it. And if your code uses global data, then it becomes difficult to split it out from the rest.
- [ ] You’ll see this problem when you’re writing unit tests for code that uses global data. You’ll find yourself writing a bunch of setup code to create a global environment just to allow your test to run.
- [ ] Global Data Includes Singletons
- [ ] In the previous section we were careful to talk about global data and not global variables. That’s because people often tell us “Look! No global variables. I wrapped it all as instance data in a singleton object or global module.”
- [ ] Try again, Skippy. If all you have is a singleton with a bunch of exported instance variables, then it’s still just global data. It just has a longer name.
- [ ] In the observer pattern we have a source of events, called the observable and a list of clients, the observers, who are interested in those events.
- [ ] An observer registers its interest with the observable, typically by passing a reference to a function to be called. Subsequently, when the event occurs, the observable iterates down its list of observers and calls the function that each passed it. The event is given as a parameter to that call.
- [ ] In the pubsub model, we have publishers and subscribers. These are connected via channels. The channels are implemented in a separate body of code: sometimes a library, sometimes a process, and sometimes a distributed infrastructure. All this implementation detail is hidden from your code.
- [ ] Pubsub is a good technology for decoupling the handling of asynchronous events. It allows code to be added and replaced, potentially while the application is running, without altering existing code. The downside is that it can be hard to see what is going on in a system that uses pubsub heavily: you can’t look at a publisher and immediately see which subscribers are involved with a particular message.
- [ ] If you’ve ever used a spreadsheet, then you’ll be familiar with reactive programming. If a cell contains a formula which refers to a second cell, then updating that second cell causes the first to update as well. The values react as the values they use change.
- [ ] two styles of inheritance (which actually had a fair amount in common) developed over the following decades. The Simula approach, which suggested inheritance was a way of combining types, continued in languages such as C++ and Java. The Smalltalk school, where inheritance was a dynamic organization of behaviors, was seen in languages such as Ruby and JavaScript.
- [ ] Concurrency is when the execution of two or more pieces of code act as if they run at the same time. Parallelism is when they do run at the same time. 
- [ ] we need to model and analyze the application workflows as part of the design. We’d like to find out what can happen at the same time, and what must happen in a strict order. One way to do this is to capture the workflow using a notation such as the activity diagram. 
- [ ] A lot of attention is given to shared memory as a source of concurrency problems, but in fact the problems can pop up anywhere where your application code shares mutable resources: files, databases, external services, and so on. Whenever two or more instances of your code can access some resource at the same time, you’re looking at a potential problem. 
- [ ] Coding is not mechanical. If it were, all the CASE tools that people pinned their hopes on way back in the early 1980s would have replaced programmers long ago. There are decisions to be made every minute—decisions that require careful thought and judgment if the resulting program is to enjoy a long, accurate, and productive life. 
- [ ] Sometimes code just flies from your brain into the editor: ideas become bits with seemingly no effort. 
- [ ] Other days, coding feels like walking uphill in mud. Taking each step requires tremendous effort, and every three steps you slide back two. 
- [ ] A large part of our job is dealing with existing code, often written by other people. Those people will have different instincts to you, and so the decisions they made will be different. Not necessarily worse; just different. 
- [ ] You refactor when you’ve learned something; when you understand something better than you did last year, yesterday, or even just ten minutes ago. 
- [ ] Even the best sets of tests are unlikely to find all the bugs; there’s something about the damp, warm conditions of a production environment that seems to bring them out of the woodwork. 
- [ ] All software you write will be tested—if not by you and your team, then by the eventual users—so you might as well plan on testing it thoroughly. A little forethought can go a long way toward minimizing maintenance costs and help-desk calls. 
- [ ] When coding, you may go through several cycles of “it works!” and “why isn’t that working?” with the occasional “there’s no way that could have happened...”[62] After several hills and bumps on this uphill climb, it’s easy to say to yourself, “phew, it all works!” and proclaim the code done. Of course, it’s not done yet. You’re 90% done, but now you have the other 90% to consider. 
- [ ] Sometimes you will find yourself working on a problem that seems much harder than you thought it should be. Maybe it feels like you’re going down the wrong path—that there must be an easier way than this! Perhaps you are running late on the schedule now, or even despair of ever getting the system to work because this particular problem is “impossible.” 
- [ ] This is an ideal time to do something else for a while. Work on something different. Go walk the dog. Sleep on it. 
- [ ] pragmatic team is small, under 10-12 or so members. 
- [ ] Members come and go rarely. Everyone knows everyone well, trusts each other, and depends on each other. 
- [ ] Have you or your team fallen in this trap? Ask yourself, why are you even using that particular development method? Or that framework? Or that testing technique? Is it actually well-suited for the job at hand? Does it work well for you? Or was it adopted just because it was being used by the latest internet-fueled success story? 
- [ ] The goal of course isn’t to “do Scrum,” “do agile,” “do Lean,” or what-have-you. The goal is to be in a position to deliver working software that gives the users some new capability at a moment’s notice. Not weeks, months, or years from now, but now. 
- [ ] Anonymity, especially on large projects, can provide a breeding ground for sloppiness, mistakes, sloth, and bad code. It becomes too easy to see yourself as just a cog in the wheel, producing lame excuses in endless status reports instead of good code. 